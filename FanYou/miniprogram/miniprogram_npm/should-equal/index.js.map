{"version":3,"sources":["should-equal.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar t = _interopDefault(require('should-type'));\n\nfunction format(msg) {\n  var args = arguments;\n  for (var i = 1, l = args.length; i < l; i++) {\n    msg = msg.replace(/%s/, args[i]);\n  }\n  return msg;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction EqualityFail(a, b, reason, path) {\n  this.a = a;\n  this.b = b;\n  this.reason = reason;\n  this.path = path;\n}\n\nfunction typeToString(tp) {\n  return tp.type + (tp.cls ? \"(\" + tp.cls + (tp.sub ? \" \" + tp.sub : \"\") + \")\" : \"\");\n}\n\nvar PLUS_0_AND_MINUS_0 = \"+0 is not equal to -0\";\nvar DIFFERENT_TYPES = \"A has type %s and B has type %s\";\nvar EQUALITY = \"A is not equal to B\";\nvar EQUALITY_PROTOTYPE = \"A and B have different prototypes\";\nvar WRAPPED_VALUE = \"A wrapped value is not equal to B wrapped value\";\nvar FUNCTION_SOURCES = \"function A is not equal to B by source code value (via .toString call)\";\nvar MISSING_KEY = \"%s has no key %s\";\nvar SET_MAP_MISSING_KEY = \"Set/Map missing key %s\";\n\nvar DEFAULT_OPTIONS = {\n  checkProtoEql: true,\n  checkSubType: true,\n  plusZeroAndMinusZeroEqual: true,\n  collectAllFails: false\n};\n\nfunction setBooleanDefault(property, obj, opts, defaults) {\n  obj[property] = typeof opts[property] !== \"boolean\" ? defaults[property] : opts[property];\n}\n\nvar METHOD_PREFIX = \"_check_\";\n\nfunction EQ(opts, a, b, path) {\n  opts = opts || {};\n\n  setBooleanDefault(\"checkProtoEql\", this, opts, DEFAULT_OPTIONS);\n  setBooleanDefault(\"plusZeroAndMinusZeroEqual\", this, opts, DEFAULT_OPTIONS);\n  setBooleanDefault(\"checkSubType\", this, opts, DEFAULT_OPTIONS);\n  setBooleanDefault(\"collectAllFails\", this, opts, DEFAULT_OPTIONS);\n\n  this.a = a;\n  this.b = b;\n\n  this._meet = opts._meet || [];\n\n  this.fails = opts.fails || [];\n\n  this.path = path || [];\n}\n\nfunction ShortcutError(fail) {\n  this.name = \"ShortcutError\";\n  this.message = \"fail fast\";\n  this.fail = fail;\n}\n\nShortcutError.prototype = Object.create(Error.prototype);\n\nEQ.checkStrictEquality = function(a, b) {\n  this.collectFail(a !== b, EQUALITY);\n};\n\nEQ.add = function add(type, cls, sub, f) {\n  var args = Array.prototype.slice.call(arguments);\n  f = args.pop();\n  EQ.prototype[METHOD_PREFIX + args.join(\"_\")] = f;\n};\n\nEQ.prototype = {\n  check: function() {\n    try {\n      this.check0();\n    } catch (e) {\n      if (e instanceof ShortcutError) {\n        return [e.fail];\n      }\n      throw e;\n    }\n    return this.fails;\n  },\n\n  check0: function() {\n    var a = this.a;\n    var b = this.b;\n\n    // equal a and b exit early\n    if (a === b) {\n      // check for +0 !== -0;\n      return this.collectFail(a === 0 && 1 / a !== 1 / b && !this.plusZeroAndMinusZeroEqual, PLUS_0_AND_MINUS_0);\n    }\n\n    var typeA = t(a);\n    var typeB = t(b);\n\n    // if objects has different types they are not equal\n    if (typeA.type !== typeB.type || typeA.cls !== typeB.cls || typeA.sub !== typeB.sub) {\n      return this.collectFail(true, format(DIFFERENT_TYPES, typeToString(typeA), typeToString(typeB)));\n    }\n\n    // as types the same checks type specific things\n    var name1 = typeA.type,\n      name2 = typeA.type;\n    if (typeA.cls) {\n      name1 += \"_\" + typeA.cls;\n      name2 += \"_\" + typeA.cls;\n    }\n    if (typeA.sub) {\n      name2 += \"_\" + typeA.sub;\n    }\n\n    var f =\n      this[METHOD_PREFIX + name2] ||\n      this[METHOD_PREFIX + name1] ||\n      this[METHOD_PREFIX + typeA.type] ||\n      this.defaultCheck;\n\n    f.call(this, this.a, this.b);\n  },\n\n  collectFail: function(comparison, reason, showReason) {\n    if (comparison) {\n      var res = new EqualityFail(this.a, this.b, reason, this.path);\n      res.showReason = !!showReason;\n\n      this.fails.push(res);\n\n      if (!this.collectAllFails) {\n        throw new ShortcutError(res);\n      }\n    }\n  },\n\n  checkPlainObjectsEquality: function(a, b) {\n    // compare deep objects and arrays\n    // stacks contain references only\n    //\n    var meet = this._meet;\n    var m = this._meet.length;\n    while (m--) {\n      var st = meet[m];\n      if (st[0] === a && st[1] === b) {\n        return;\n      }\n    }\n\n    // add `a` and `b` to the stack of traversed objects\n    meet.push([a, b]);\n\n    // TODO maybe something else like getOwnPropertyNames\n    var key;\n    for (key in b) {\n      if (hasOwnProperty.call(b, key)) {\n        if (hasOwnProperty.call(a, key)) {\n          this.checkPropertyEquality(key);\n        } else {\n          this.collectFail(true, format(MISSING_KEY, \"A\", key));\n        }\n      }\n    }\n\n    // ensure both objects have the same number of properties\n    for (key in a) {\n      if (hasOwnProperty.call(a, key)) {\n        this.collectFail(!hasOwnProperty.call(b, key), format(MISSING_KEY, \"B\", key));\n      }\n    }\n\n    meet.pop();\n\n    if (this.checkProtoEql) {\n      //TODO should i check prototypes for === or use eq?\n      this.collectFail(Object.getPrototypeOf(a) !== Object.getPrototypeOf(b), EQUALITY_PROTOTYPE, true);\n    }\n  },\n\n  checkPropertyEquality: function(propertyName) {\n    var _eq = new EQ(this, this.a[propertyName], this.b[propertyName], this.path.concat([propertyName]));\n    _eq.check0();\n  },\n\n  defaultCheck: EQ.checkStrictEquality\n};\n\nEQ.add(t.NUMBER, function(a, b) {\n  this.collectFail((a !== a && b === b) || (b !== b && a === a) || (a !== b && a === a && b === b), EQUALITY);\n});\n\n[t.SYMBOL, t.BOOLEAN, t.STRING].forEach(function(tp) {\n  EQ.add(tp, EQ.checkStrictEquality);\n});\n\nEQ.add(t.FUNCTION, function(a, b) {\n  // functions are compared by their source code\n  this.collectFail(a.toString() !== b.toString(), FUNCTION_SOURCES);\n  // check user properties\n  this.checkPlainObjectsEquality(a, b);\n});\n\nEQ.add(t.OBJECT, t.REGEXP, function(a, b) {\n  // check regexp flags\n  var flags = [\"source\", \"global\", \"multiline\", \"lastIndex\", \"ignoreCase\", \"sticky\", \"unicode\"];\n  while (flags.length) {\n    this.checkPropertyEquality(flags.shift());\n  }\n  // check user properties\n  this.checkPlainObjectsEquality(a, b);\n});\n\nEQ.add(t.OBJECT, t.DATE, function(a, b) {\n  //check by timestamp only (using .valueOf)\n  this.collectFail(+a !== +b, EQUALITY);\n  // check user properties\n  this.checkPlainObjectsEquality(a, b);\n});\n\n[t.NUMBER, t.BOOLEAN, t.STRING].forEach(function(tp) {\n  EQ.add(t.OBJECT, tp, function(a, b) {\n    //primitive type wrappers\n    this.collectFail(a.valueOf() !== b.valueOf(), WRAPPED_VALUE);\n    // check user properties\n    this.checkPlainObjectsEquality(a, b);\n  });\n});\n\nEQ.add(t.OBJECT, function(a, b) {\n  this.checkPlainObjectsEquality(a, b);\n});\n\n[t.ARRAY, t.ARGUMENTS, t.TYPED_ARRAY].forEach(function(tp) {\n  EQ.add(t.OBJECT, tp, function(a, b) {\n    this.checkPropertyEquality(\"length\");\n\n    this.checkPlainObjectsEquality(a, b);\n  });\n});\n\nEQ.add(t.OBJECT, t.ARRAY_BUFFER, function(a, b) {\n  this.checkPropertyEquality(\"byteLength\");\n\n  this.checkPlainObjectsEquality(a, b);\n});\n\nEQ.add(t.OBJECT, t.ERROR, function(a, b) {\n  this.checkPropertyEquality(\"name\");\n  this.checkPropertyEquality(\"message\");\n\n  this.checkPlainObjectsEquality(a, b);\n});\n\nEQ.add(t.OBJECT, t.BUFFER, function(a) {\n  this.checkPropertyEquality(\"length\");\n\n  var l = a.length;\n  while (l--) {\n    this.checkPropertyEquality(l);\n  }\n\n  //we do not check for user properties because\n  //node Buffer have some strange hidden properties\n});\n\nfunction checkMapByKeys(a, b) {\n  var iteratorA = a.keys();\n\n  for (var nextA = iteratorA.next(); !nextA.done; nextA = iteratorA.next()) {\n    var key = nextA.value;\n    var hasKey = b.has(key);\n    this.collectFail(!hasKey, format(SET_MAP_MISSING_KEY, key));\n\n    if (hasKey) {\n      var valueB = b.get(key);\n      var valueA = a.get(key);\n\n      eq(valueA, valueB, this);\n    }\n  }\n}\n\nfunction checkSetByKeys(a, b) {\n  var iteratorA = a.keys();\n\n  for (var nextA = iteratorA.next(); !nextA.done; nextA = iteratorA.next()) {\n    var key = nextA.value;\n    var hasKey = b.has(key);\n    this.collectFail(!hasKey, format(SET_MAP_MISSING_KEY, key));\n  }\n}\n\nEQ.add(t.OBJECT, t.MAP, function(a, b) {\n  this._meet.push([a, b]);\n\n  checkMapByKeys.call(this, a, b);\n  checkMapByKeys.call(this, b, a);\n\n  this._meet.pop();\n\n  this.checkPlainObjectsEquality(a, b);\n});\nEQ.add(t.OBJECT, t.SET, function(a, b) {\n  this._meet.push([a, b]);\n\n  checkSetByKeys.call(this, a, b);\n  checkSetByKeys.call(this, b, a);\n\n  this._meet.pop();\n\n  this.checkPlainObjectsEquality(a, b);\n});\n\nfunction eq(a, b, opts) {\n  return new EQ(opts, a, b).check();\n}\n\neq.EQ = EQ;\n\nmodule.exports = eq;"]}