{"version":3,"sources":["should-type-adaptors.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar shouldUtil = require('should-util');\nvar t = _interopDefault(require('should-type'));\n\n// TODO in future add generators instead of forEach and iterator implementation\n\n\nfunction ObjectIterator(obj) {\n  this._obj = obj;\n}\n\nObjectIterator.prototype = {\n  __shouldIterator__: true, // special marker\n\n  next: function() {\n    if (this._done) {\n      throw new Error('Iterator already reached the end');\n    }\n\n    if (!this._keys) {\n      this._keys = Object.keys(this._obj);\n      this._index = 0;\n    }\n\n    var key = this._keys[this._index];\n    this._done = this._index === this._keys.length;\n    this._index += 1;\n\n    return {\n      value: this._done ? void 0: [key, this._obj[key]],\n      done: this._done\n    };\n  }\n};\n\nif (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n  ObjectIterator.prototype[Symbol.iterator] = function() {\n    return this;\n  };\n}\n\n\nfunction TypeAdaptorStorage() {\n  this._typeAdaptors = [];\n  this._iterableTypes = {};\n}\n\nTypeAdaptorStorage.prototype = {\n  add: function(type, cls, sub, adaptor) {\n    return this.addType(new t.Type(type, cls, sub), adaptor);\n  },\n\n  addType: function(type, adaptor) {\n    this._typeAdaptors[type.toString()] = adaptor;\n  },\n\n  getAdaptor: function(tp, funcName) {\n    var tries = tp.toTryTypes();\n    while (tries.length) {\n      var toTry = tries.shift();\n      var ad = this._typeAdaptors[toTry];\n      if (ad && ad[funcName]) {\n        return ad[funcName];\n      }\n    }\n  },\n\n  requireAdaptor: function(tp, funcName) {\n    var a = this.getAdaptor(tp, funcName);\n    if (!a) {\n      throw new Error('There is no type adaptor `' + funcName + '` for ' + tp.toString());\n    }\n    return a;\n  },\n\n  addIterableType: function(tp) {\n    this._iterableTypes[tp.toString()] = true;\n  },\n\n  isIterableType: function(tp) {\n    return !!this._iterableTypes[tp.toString()];\n  }\n};\n\nvar defaultTypeAdaptorStorage = new TypeAdaptorStorage();\n\nvar objectAdaptor = {\n  forEach: function(obj, f, context) {\n    for (var prop in obj) {\n      if (shouldUtil.hasOwnProperty(obj, prop) && shouldUtil.propertyIsEnumerable(obj, prop)) {\n        if (f.call(context, obj[prop], prop, obj) === false) {\n          return;\n        }\n      }\n    }\n  },\n\n  has: function(obj, prop) {\n    return shouldUtil.hasOwnProperty(obj, prop);\n  },\n\n  get: function(obj, prop) {\n    return obj[prop];\n  },\n\n  iterator: function(obj) {\n    return new ObjectIterator(obj);\n  }\n};\n\n// default for objects\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT), objectAdaptor);\ndefaultTypeAdaptorStorage.addType(new t.Type(t.FUNCTION), objectAdaptor);\n\nvar mapAdaptor = {\n  has: function(obj, key) {\n    return obj.has(key);\n  },\n\n  get: function(obj, key) {\n    return obj.get(key);\n  },\n\n  forEach: function(obj, f, context) {\n    var iter = obj.entries();\n    forEach(iter, function(value) {\n      return f.call(context, value[1], value[0], obj);\n    });\n  },\n\n  size: function(obj) {\n    return obj.size;\n  },\n\n  isEmpty: function(obj) {\n    return obj.size === 0;\n  },\n\n  iterator: function(obj) {\n    return obj.entries();\n  }\n};\n\nvar setAdaptor = shouldUtil.merge({}, mapAdaptor);\nsetAdaptor.get = function(obj, key) {\n  if (obj.has(key)) {\n    return key;\n  }\n};\nsetAdaptor.iterator = function(obj) {\n  return obj.values();\n};\n\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.MAP), mapAdaptor);\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.SET), setAdaptor);\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.WEAK_SET), setAdaptor);\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.WEAK_MAP), mapAdaptor);\n\ndefaultTypeAdaptorStorage.addType(new t.Type(t.STRING), {\n  isEmpty: function(obj) {\n    return obj === '';\n  },\n\n  size: function(obj) {\n    return obj.length;\n  }\n});\n\ndefaultTypeAdaptorStorage.addIterableType(new t.Type(t.OBJECT, t.ARRAY));\ndefaultTypeAdaptorStorage.addIterableType(new t.Type(t.OBJECT, t.ARGUMENTS));\ndefaultTypeAdaptorStorage.addIterableType(new t.Type(t.OBJECT, t.SET));\n\nfunction forEach(obj, f, context) {\n  if (shouldUtil.isGeneratorFunction(obj)) {\n    return forEach(obj(), f, context);\n  } else if (shouldUtil.isIterator(obj)) {\n    var value = obj.next();\n    while (!value.done) {\n      if (f.call(context, value.value, 'value', obj) === false) {\n        return;\n      }\n      value = obj.next();\n    }\n  } else {\n    var type = t(obj);\n    var func = defaultTypeAdaptorStorage.requireAdaptor(type, 'forEach');\n    func(obj, f, context);\n  }\n}\n\n\nfunction size(obj) {\n  var type = t(obj);\n  var func = defaultTypeAdaptorStorage.getAdaptor(type, 'size');\n  if (func) {\n    return func(obj);\n  } else {\n    var len = 0;\n    forEach(obj, function() {\n      len += 1;\n    });\n    return len;\n  }\n}\n\nfunction isEmpty(obj) {\n  var type = t(obj);\n  var func = defaultTypeAdaptorStorage.getAdaptor(type, 'isEmpty');\n  if (func) {\n    return func(obj);\n  } else {\n    var res = true;\n    forEach(obj, function() {\n      res = false;\n      return false;\n    });\n    return res;\n  }\n}\n\n// return boolean if obj has such 'key'\nfunction has(obj, key) {\n  var type = t(obj);\n  var func = defaultTypeAdaptorStorage.requireAdaptor(type, 'has');\n  return func(obj, key);\n}\n\n// return value for given key\nfunction get(obj, key) {\n  var type = t(obj);\n  var func = defaultTypeAdaptorStorage.requireAdaptor(type, 'get');\n  return func(obj, key);\n}\n\nfunction reduce(obj, f, initialValue) {\n  var res = initialValue;\n  forEach(obj, function(value, key) {\n    res = f(res, value, key, obj);\n  });\n  return res;\n}\n\nfunction some(obj, f, context) {\n  var res = false;\n  forEach(obj, function(value, key) {\n    if (f.call(context, value, key, obj)) {\n      res = true;\n      return false;\n    }\n  }, context);\n  return res;\n}\n\nfunction every(obj, f, context) {\n  var res = true;\n  forEach(obj, function(value, key) {\n    if (!f.call(context, value, key, obj)) {\n      res = false;\n      return false;\n    }\n  }, context);\n  return res;\n}\n\nfunction isIterable(obj) {\n  return defaultTypeAdaptorStorage.isIterableType(t(obj));\n}\n\nfunction iterator(obj) {\n  return defaultTypeAdaptorStorage.requireAdaptor(t(obj), 'iterator')(obj);\n}\n\nexports.defaultTypeAdaptorStorage = defaultTypeAdaptorStorage;\nexports.forEach = forEach;\nexports.size = size;\nexports.isEmpty = isEmpty;\nexports.has = has;\nexports.get = get;\nexports.reduce = reduce;\nexports.some = some;\nexports.every = every;\nexports.isIterable = isIterable;\nexports.iterator = iterator;"]}