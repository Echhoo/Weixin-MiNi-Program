{"version":3,"sources":["should.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar getType = _interopDefault(require('should-type'));\nvar eql = _interopDefault(require('should-equal'));\nvar sformat = _interopDefault(require('should-format'));\nvar shouldTypeAdaptors = require('should-type-adaptors');\nvar shouldUtil = require('should-util');\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2017 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\nfunction isWrapperType(obj) {\n  return obj instanceof Number || obj instanceof String || obj instanceof Boolean;\n}\n\n// XXX make it more strict: numbers, strings, symbols - and nothing else\nfunction convertPropertyName(name) {\n  return typeof name === \"symbol\" ? name : String(name);\n}\n\nvar functionName = sformat.functionName;\n\nfunction isPlainObject(obj) {\n  if (typeof obj == \"object\" && obj !== null) {\n    var proto = Object.getPrototypeOf(obj);\n    return proto === Object.prototype || proto === null;\n  }\n\n  return false;\n}\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2017 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar config = {\n  typeAdaptors: shouldTypeAdaptors.defaultTypeAdaptorStorage,\n\n  getFormatter: function(opts) {\n    return new sformat.Formatter(opts || config);\n  }\n};\n\nfunction format(value, opts) {\n  return config.getFormatter(opts).format(value);\n}\n\nfunction formatProp(value) {\n  var formatter = config.getFormatter();\n  return sformat.formatPlainObjectKey.call(formatter, value);\n}\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2017 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n/**\n * should AssertionError\n * @param {Object} options\n * @constructor\n * @memberOf should\n * @static\n */\nfunction AssertionError(options) {\n  shouldUtil.merge(this, options);\n\n  if (!options.message) {\n    Object.defineProperty(this, \"message\", {\n      get: function() {\n        if (!this._message) {\n          this._message = this.generateMessage();\n          this.generatedMessage = true;\n        }\n        return this._message;\n      },\n      configurable: true,\n      enumerable: false\n    });\n  }\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      if (this.stackStartFunction) {\n        // try to strip useless frames\n        var fn_name = functionName(this.stackStartFunction);\n        var idx = out.indexOf(\"\\n\" + fn_name);\n        if (idx >= 0) {\n          // once we have located the function frame\n          // we need to strip out everything before it (and its line)\n          var next_line = out.indexOf(\"\\n\", idx + 1);\n          out = out.substring(next_line + 1);\n        }\n      }\n\n      this.stack = out;\n    }\n  }\n}\n\nvar indent = \"    \";\nfunction prependIndent(line) {\n  return indent + line;\n}\n\nfunction indentLines(text) {\n  return text\n    .split(\"\\n\")\n    .map(prependIndent)\n    .join(\"\\n\");\n}\n\n// assert.AssertionError instanceof Error\nAssertionError.prototype = Object.create(Error.prototype, {\n  name: {\n    value: \"AssertionError\"\n  },\n\n  generateMessage: {\n    value: function() {\n      if (!this.operator && this.previous) {\n        return this.previous.message;\n      }\n      var actual = format(this.actual);\n      var expected = \"expected\" in this ? \" \" + format(this.expected) : \"\";\n      var details =\n        \"details\" in this && this.details ? \" (\" + this.details + \")\" : \"\";\n\n      var previous = this.previous\n        ? \"\\n\" + indentLines(this.previous.message)\n        : \"\";\n\n      return (\n        \"expected \" +\n        actual +\n        (this.negate ? \" not \" : \" \") +\n        this.operator +\n        expected +\n        details +\n        previous\n      );\n    }\n  }\n});\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2017 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\n// a bit hacky way how to get error to do not have stack\nfunction LightAssertionError(options) {\n  shouldUtil.merge(this, options);\n\n  if (!options.message) {\n    Object.defineProperty(this, \"message\", {\n      get: function() {\n        if (!this._message) {\n          this._message = this.generateMessage();\n          this.generatedMessage = true;\n        }\n        return this._message;\n      }\n    });\n  }\n}\n\nLightAssertionError.prototype = {\n  generateMessage: AssertionError.prototype.generateMessage\n};\n\n/**\n * should Assertion\n * @param {*} obj Given object for assertion\n * @constructor\n * @memberOf should\n * @static\n */\nfunction Assertion(obj) {\n  this.obj = obj;\n\n  this.anyOne = false;\n  this.negate = false;\n\n  this.params = { actual: obj };\n}\n\nAssertion.prototype = {\n  constructor: Assertion,\n\n  /**\n   * Base method for assertions.\n   *\n   * Before calling this method need to fill Assertion#params object. This method usually called from other assertion methods.\n   * `Assertion#params` can contain such properties:\n   * * `operator` - required string containing description of this assertion\n   * * `obj` - optional replacement for this.obj, it is useful if you prepare more clear object then given\n   * * `message` - if this property filled with string any others will be ignored and this one used as assertion message\n   * * `expected` - any object used when you need to assert relation between given object and expected. Like given == expected (== is a relation)\n   * * `details` - additional string with details to generated message\n   *\n   * @memberOf Assertion\n   * @category assertion\n   * @param {*} expr Any expression that will be used as a condition for asserting.\n   * @example\n   *\n   * var a = new should.Assertion(42);\n   *\n   * a.params = {\n   *  operator: 'to be magic number',\n   * }\n   *\n   * a.assert(false);\n   * //throws AssertionError: expected 42 to be magic number\n   */\n  assert: function(expr) {\n    if (expr) {\n      return this;\n    }\n\n    var params = this.params;\n\n    if (\"obj\" in params && !(\"actual\" in params)) {\n      params.actual = params.obj;\n    } else if (!(\"obj\" in params) && !(\"actual\" in params)) {\n      params.actual = this.obj;\n    }\n\n    params.stackStartFunction = params.stackStartFunction || this.assert;\n    params.negate = this.negate;\n\n    params.assertion = this;\n\n    if (this.light) {\n      throw new LightAssertionError(params);\n    } else {\n      throw new AssertionError(params);\n    }\n  },\n\n  /**\n   * Shortcut for `Assertion#assert(false)`.\n   *\n   * @memberOf Assertion\n   * @category assertion\n   * @example\n   *\n   * var a = new should.Assertion(42);\n   *\n   * a.params = {\n   *  operator: 'to be magic number',\n   * }\n   *\n   * a.fail();\n   * //throws AssertionError: expected 42 to be magic number\n   */\n  fail: function() {\n    return this.assert(false);\n  },\n\n  assertZeroArguments: function(args) {\n    if (args.length !== 0) {\n      throw new TypeError(\"This assertion does not expect any arguments. You may need to check your code\");\n    }\n  }\n};\n\n/**\n * Assertion used to delegate calls of Assertion methods inside of Promise.\n * It has almost all methods of Assertion.prototype\n *\n * @param {Promise} obj\n */\nfunction PromisedAssertion(/* obj */) {\n  Assertion.apply(this, arguments);\n}\n\n/**\n * Make PromisedAssertion to look like promise. Delegate resolve and reject to given promise.\n *\n * @private\n * @returns {Promise}\n */\nPromisedAssertion.prototype.then = function(resolve, reject) {\n  return this.obj.then(resolve, reject);\n};\n\n/**\n * Way to extend Assertion function. It uses some logic\n * to define only positive assertions and itself rule with negative assertion.\n *\n * All actions happen in subcontext and this method take care about negation.\n * Potentially we can add some more modifiers that does not depends from state of assertion.\n *\n * @memberOf Assertion\n * @static\n * @param {String} name Name of assertion. It will be used for defining method or getter on Assertion.prototype\n * @param {Function} func Function that will be called on executing assertion\n * @example\n *\n * Assertion.add('asset', function() {\n *      this.params = { operator: 'to be asset' }\n *\n *      this.obj.should.have.property('id').which.is.a.Number()\n *      this.obj.should.have.property('path')\n * })\n */\nAssertion.add = function(name, func) {\n  Object.defineProperty(Assertion.prototype, name, {\n    enumerable: true,\n    configurable: true,\n    value: function() {\n      var context = new Assertion(this.obj, this, name);\n      context.anyOne = this.anyOne;\n      context.onlyThis = this.onlyThis;\n      // hack\n      context.light = true;\n\n      try {\n        func.apply(context, arguments);\n      } catch (e) {\n        // check for fail\n        if (e instanceof AssertionError || e instanceof LightAssertionError) {\n          // negative fail\n          if (this.negate) {\n            this.obj = context.obj;\n            this.negate = false;\n            return this;\n          }\n\n          if (context !== e.assertion) {\n            context.params.previous = e;\n          }\n\n          // positive fail\n          context.negate = false;\n          // hack\n          context.light = false;\n          context.fail();\n        }\n        // throw if it is another exception\n        throw e;\n      }\n\n      // negative pass\n      if (this.negate) {\n        context.negate = true; // because .fail will set negate\n        context.params.details = \"false negative fail\";\n        // hack\n        context.light = false;\n        context.fail();\n      }\n\n      // positive pass\n      if (!this.params.operator) {\n        this.params = context.params; // shortcut\n      }\n      this.obj = context.obj;\n      this.negate = false;\n      return this;\n    }\n  });\n\n  Object.defineProperty(PromisedAssertion.prototype, name, {\n    enumerable: true,\n    configurable: true,\n    value: function() {\n      var args = arguments;\n      this.obj = this.obj.then(function(a) {\n        return a[name].apply(a, args);\n      });\n\n      return this;\n    }\n  });\n};\n\n/**\n * Add chaining getter to Assertion like .a, .which etc\n *\n * @memberOf Assertion\n * @static\n * @param  {string} name   name of getter\n * @param  {function} [onCall] optional function to call\n */\nAssertion.addChain = function(name, onCall) {\n  onCall = onCall || function() {};\n  Object.defineProperty(Assertion.prototype, name, {\n    get: function() {\n      onCall.call(this);\n      return this;\n    },\n    enumerable: true\n  });\n\n  Object.defineProperty(PromisedAssertion.prototype, name, {\n    enumerable: true,\n    configurable: true,\n    get: function() {\n      this.obj = this.obj.then(function(a) {\n        return a[name];\n      });\n\n      return this;\n    }\n  });\n};\n\n/**\n * Create alias for some `Assertion` property\n *\n * @memberOf Assertion\n * @static\n * @param {String} from Name of to map\n * @param {String} to Name of alias\n * @example\n *\n * Assertion.alias('true', 'True')\n */\nAssertion.alias = function(from, to) {\n  var desc = Object.getOwnPropertyDescriptor(Assertion.prototype, from);\n  if (!desc) {\n    throw new Error(\"Alias \" + from + \" -> \" + to + \" could not be created as \" + from + \" not defined\");\n  }\n  Object.defineProperty(Assertion.prototype, to, desc);\n\n  var desc2 = Object.getOwnPropertyDescriptor(PromisedAssertion.prototype, from);\n  if (desc2) {\n    Object.defineProperty(PromisedAssertion.prototype, to, desc2);\n  }\n};\n/**\n * Negation modifier. Current assertion chain become negated. Each call invert negation on current assertion.\n *\n * @name not\n * @property\n * @memberOf Assertion\n * @category assertion\n */\nAssertion.addChain(\"not\", function() {\n  this.negate = !this.negate;\n});\n\n/**\n * Any modifier - it affect on execution of sequenced assertion to do not `check all`, but `check any of`.\n *\n * @name any\n * @property\n * @memberOf Assertion\n * @category assertion\n */\nAssertion.addChain(\"any\", function() {\n  this.anyOne = true;\n});\n\n/**\n * Only modifier - currently used with .keys to check if object contains only exactly this .keys\n *\n * @name only\n * @property\n * @memberOf Assertion\n * @category assertion\n */\nAssertion.addChain(\"only\", function() {\n  this.onlyThis = true;\n});\n\n// implement assert interface using already written peaces of should.js\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// when used in node, this will actually load the util module we depend on\n// versus loading the builtin util module as happens otherwise\n// this is a bug in node module loading as far as I am concerned\nvar pSlice = Array.prototype.slice;\n\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = ok;\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n/**\n * Node.js standard [`assert.fail`](http://nodejs.org/api/assert.html#assert_assert_fail_actual_expected_message_operator).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual Actual object\n * @param {*} expected Expected object\n * @param {string} message Message for assertion\n * @param {string} operator Operator text\n */\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  var a = new Assertion(actual);\n  a.params = {\n    operator: operator,\n    expected: expected,\n    message: message,\n    stackStartFunction: stackStartFunction || fail\n  };\n\n  a.fail();\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n/**\n * Node.js standard [`assert.ok`](http://nodejs.org/api/assert.html#assert_assert_value_message_assert_ok_value_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} value\n * @param {string} [message]\n */\nfunction ok(value, message) {\n  if (!value) {\n    fail(value, true, message, \"==\", assert.ok);\n  }\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\n/**\n * Node.js standard [`assert.equal`](http://nodejs.org/api/assert.html#assert_assert_equal_actual_expected_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) {\n    fail(actual, expected, message, \"==\", assert.equal);\n  }\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.notEqual`](http://nodejs.org/api/assert.html#assert_assert_notequal_actual_expected_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, \"!=\", assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.deepEqual`](http://nodejs.org/api/assert.html#assert_assert_deepequal_actual_expected_message).\n * But uses should.js .eql implementation instead of Node.js own deepEqual.\n *\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (eql(actual, expected).length !== 0) {\n    fail(actual, expected, message, \"deepEqual\", assert.deepEqual);\n  }\n};\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.notDeepEqual`](http://nodejs.org/api/assert.html#assert_assert_notdeepequal_actual_expected_message).\n * But uses should.js .eql implementation instead of Node.js own deepEqual.\n *\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (eql(actual, expected).result) {\n    fail(actual, expected, message, \"notDeepEqual\", assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.strictEqual`](http://nodejs.org/api/assert.html#assert_assert_strictequal_actual_expected_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, \"===\", assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.notStrictEqual`](http://nodejs.org/api/assert.html#assert_assert_notstrictequal_actual_expected_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, \"!==\", assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == \"[object RegExp]\") {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected == \"string\") {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message =\n    (expected && expected.name ? \" (\" + expected.name + \")\" : \".\") +\n    (message ? \" \" + message : \".\");\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, \"Missing expected exception\" + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(actual, expected, \"Got unwanted exception\" + message);\n  }\n\n  if (\n    (shouldThrow &&\n      actual &&\n      expected &&\n      !expectedException(actual, expected)) ||\n    (!shouldThrow && actual)\n  ) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n/**\n * Node.js standard [`assert.throws`](http://nodejs.org/api/assert.html#assert_assert_throws_block_error_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {Function} block\n * @param {Function} [error]\n * @param {String} [message]\n */\nassert.throws = function(/*block, error, message*/) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\n/**\n * Node.js standard [`assert.doesNotThrow`](http://nodejs.org/api/assert.html#assert_assert_doesnotthrow_block_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {Function} block\n * @param {String} [message]\n */\nassert.doesNotThrow = function(/*block, message*/) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\n/**\n * Node.js standard [`assert.ifError`](http://nodejs.org/api/assert.html#assert_assert_iferror_value).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {Error} err\n */\nassert.ifError = function(err) {\n  if (err) {\n    throw err;\n  }\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2017 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nfunction assertExtensions(should) {\n  var i = should.format;\n\n  /*\n   * Expose assert to should\n   *\n   * This allows you to do things like below\n   * without require()ing the assert module.\n   *\n   *    should.equal(foo.bar, undefined);\n   *\n   */\n  shouldUtil.merge(should, assert);\n\n  /**\n   * Assert _obj_ exists, with optional message.\n   *\n   * @static\n   * @memberOf should\n   * @category assertion assert\n   * @alias should.exists\n   * @param {*} obj\n   * @param {String} [msg]\n   * @example\n   *\n   * should.exist(1);\n   * should.exist(new Date());\n   */\n  should.exist = should.exists = function(obj, msg) {\n    if (null == obj) {\n      throw new AssertionError({\n        message: msg || \"expected \" + i(obj) + \" to exist\",\n        stackStartFunction: should.exist\n      });\n    }\n  };\n\n  should.not = {};\n  /**\n   * Asserts _obj_ does not exist, with optional message.\n   *\n   * @name not.exist\n   * @static\n   * @memberOf should\n   * @category assertion assert\n   * @alias should.not.exists\n   * @param {*} obj\n   * @param {String} [msg]\n   * @example\n   *\n   * should.not.exist(null);\n   * should.not.exist(void 0);\n   */\n  should.not.exist = should.not.exists = function(obj, msg) {\n    if (null != obj) {\n      throw new AssertionError({\n        message: msg || \"expected \" + i(obj) + \" to not exist\",\n        stackStartFunction: should.not.exist\n      });\n    }\n  };\n}\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2017 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nfunction chainAssertions(should, Assertion) {\n  /**\n   * Simple chaining to improve readability. Does nothing.\n   *\n   * @memberOf Assertion\n   * @name be\n   * @property {should.Assertion} be\n   * @alias Assertion#an\n   * @alias Assertion#of\n   * @alias Assertion#a\n   * @alias Assertion#and\n   * @alias Assertion#been\n   * @alias Assertion#have\n   * @alias Assertion#has\n   * @alias Assertion#with\n   * @alias Assertion#is\n   * @alias Assertion#which\n   * @alias Assertion#the\n   * @alias Assertion#it\n   * @category assertion chaining\n   */\n  [\n    \"an\",\n    \"of\",\n    \"a\",\n    \"and\",\n    \"be\",\n    \"been\",\n    \"has\",\n    \"have\",\n    \"with\",\n    \"is\",\n    \"which\",\n    \"the\",\n    \"it\"\n  ].forEach(function(name) {\n    Assertion.addChain(name);\n  });\n}\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2017 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nfunction booleanAssertions(should, Assertion) {\n  /**\n   * Assert given object is exactly `true`.\n   *\n   * @name true\n   * @memberOf Assertion\n   * @category assertion bool\n   * @alias Assertion#True\n   * @param {string} [message] Optional message\n   * @example\n   *\n   * (true).should.be.true();\n   * false.should.not.be.true();\n   *\n   * ({ a: 10}).should.not.be.true();\n   */\n  Assertion.add(\"true\", function(message) {\n    this.is.exactly(true, message);\n  });\n\n  Assertion.alias(\"true\", \"True\");\n\n  /**\n   * Assert given object is exactly `false`.\n   *\n   * @name false\n   * @memberOf Assertion\n   * @category assertion bool\n   * @alias Assertion#False\n   * @param {string} [message] Optional message\n   * @example\n   *\n   * (true).should.not.be.false();\n   * false.should.be.false();\n   */\n  Assertion.add(\"false\", function(message) {\n    this.is.exactly(false, message);\n  });\n\n  Assertion.alias(\"false\", \"False\");\n\n  /**\n   * Assert given object is truthy according javascript type conversions.\n   *\n   * @name ok\n   * @memberOf Assertion\n   * @category assertion bool\n   * @example\n   *\n   * (true).should.be.ok();\n   * ''.should.not.be.ok();\n   * should(null).not.be.ok();\n   * should(void 0).not.be.ok();\n   *\n   * (10).should.be.ok();\n   * (0).should.not.be.ok();\n   */\n  Assertion.add(\"ok\", function() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be truthy\" };\n\n    this.assert(this.obj);\n  });\n}\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2017 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nfunction numberAssertions(should, Assertion) {\n  /**\n   * Assert given object is NaN\n   * @name NaN\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @example\n   *\n   * (10).should.not.be.NaN();\n   * NaN.should.be.NaN();\n   */\n  Assertion.add(\"NaN\", function() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be NaN\" };\n\n    this.assert(this.obj !== this.obj);\n  });\n\n  /**\n   * Assert given object is not finite (positive or negative)\n   *\n   * @name Infinity\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @example\n   *\n   * (10).should.not.be.Infinity();\n   * NaN.should.not.be.Infinity();\n   */\n  Assertion.add(\"Infinity\", function() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be Infinity\" };\n\n    this.is.a\n      .Number()\n      .and.not.a.NaN()\n      .and.assert(!isFinite(this.obj));\n  });\n\n  /**\n   * Assert given number between `start` and `finish` or equal one of them.\n   *\n   * @name within\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} start Start number\n   * @param {number} finish Finish number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (10).should.be.within(0, 20);\n   */\n  Assertion.add(\"within\", function(start, finish, description) {\n    this.params = {\n      operator: \"to be within \" + start + \"..\" + finish,\n      message: description\n    };\n\n    this.assert(this.obj >= start && this.obj <= finish);\n  });\n\n  /**\n   * Assert given number near some other `value` within `delta`\n   *\n   * @name approximately\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} value Center number\n   * @param {number} delta Radius\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (9.99).should.be.approximately(10, 0.1);\n   */\n  Assertion.add(\"approximately\", function(value, delta, description) {\n    this.params = {\n      operator: \"to be approximately \" + value + \" Â±\" + delta,\n      message: description\n    };\n\n    this.assert(Math.abs(this.obj - value) <= delta);\n  });\n\n  /**\n   * Assert given number above `n`.\n   *\n   * @name above\n   * @alias Assertion#greaterThan\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} n Margin number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (10).should.be.above(0);\n   */\n  Assertion.add(\"above\", function(n, description) {\n    this.params = { operator: \"to be above \" + n, message: description };\n\n    this.assert(this.obj > n);\n  });\n\n  /**\n   * Assert given number below `n`.\n   *\n   * @name below\n   * @alias Assertion#lessThan\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} n Margin number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (0).should.be.below(10);\n   */\n  Assertion.add(\"below\", function(n, description) {\n    this.params = { operator: \"to be below \" + n, message: description };\n\n    this.assert(this.obj < n);\n  });\n\n  Assertion.alias(\"above\", \"greaterThan\");\n  Assertion.alias(\"below\", \"lessThan\");\n\n  /**\n   * Assert given number above `n`.\n   *\n   * @name aboveOrEqual\n   * @alias Assertion#greaterThanOrEqual\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} n Margin number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (10).should.be.aboveOrEqual(0);\n   * (10).should.be.aboveOrEqual(10);\n   */\n  Assertion.add(\"aboveOrEqual\", function(n, description) {\n    this.params = {\n      operator: \"to be above or equal \" + n,\n      message: description\n    };\n\n    this.assert(this.obj >= n);\n  });\n\n  /**\n   * Assert given number below `n`.\n   *\n   * @name belowOrEqual\n   * @alias Assertion#lessThanOrEqual\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} n Margin number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (0).should.be.belowOrEqual(10);\n   * (0).should.be.belowOrEqual(0);\n   */\n  Assertion.add(\"belowOrEqual\", function(n, description) {\n    this.params = {\n      operator: \"to be below or equal \" + n,\n      message: description\n    };\n\n    this.assert(this.obj <= n);\n  });\n\n  Assertion.alias(\"aboveOrEqual\", \"greaterThanOrEqual\");\n  Assertion.alias(\"belowOrEqual\", \"lessThanOrEqual\");\n}\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2017 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nfunction typeAssertions(should, Assertion) {\n  /**\n   * Assert given object is number\n   * @name Number\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add(\"Number\", function() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be a number\" };\n\n    this.have.type(\"number\");\n  });\n\n  /**\n   * Assert given object is arguments\n   * @name arguments\n   * @alias Assertion#Arguments\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add(\"arguments\", function() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be arguments\" };\n\n    this.have.class(\"Arguments\");\n  });\n\n  Assertion.alias(\"arguments\", \"Arguments\");\n\n  /**\n   * Assert given object has some type using `typeof`\n   * @name type\n   * @memberOf Assertion\n   * @param {string} type Type name\n   * @param {string} [description] Optional message\n   * @category assertion types\n   */\n  Assertion.add(\"type\", function(type, description) {\n    this.params = { operator: \"to have type \" + type, message: description };\n\n    should(typeof this.obj).be.exactly(type);\n  });\n\n  /**\n   * Assert given object is instance of `constructor`\n   * @name instanceof\n   * @alias Assertion#instanceOf\n   * @memberOf Assertion\n   * @param {Function} constructor Constructor function\n   * @param {string} [description] Optional message\n   * @category assertion types\n   */\n  Assertion.add(\"instanceof\", function(constructor, description) {\n    this.params = {\n      operator: \"to be an instance of \" + functionName(constructor),\n      message: description\n    };\n\n    this.assert(Object(this.obj) instanceof constructor);\n  });\n\n  Assertion.alias(\"instanceof\", \"instanceOf\");\n\n  /**\n   * Assert given object is function\n   * @name Function\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add(\"Function\", function() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be a function\" };\n\n    this.have.type(\"function\");\n  });\n\n  /**\n   * Assert given object is object\n   * @name Object\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add(\"Object\", function() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be an object\" };\n\n    this.is.not.null().and.have.type(\"object\");\n  });\n\n  /**\n   * Assert given object is string\n   * @name String\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add(\"String\", function() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be a string\" };\n\n    this.have.type(\"string\");\n  });\n\n  /**\n   * Assert given object is array\n   * @name Array\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add(\"Array\", function() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be an array\" };\n\n    this.have.class(\"Array\");\n  });\n\n  /**\n   * Assert given object is boolean\n   * @name Boolean\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add(\"Boolean\", function() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be a boolean\" };\n\n    this.have.type(\"boolean\");\n  });\n\n  /**\n   * Assert given object is error\n   * @name Error\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add(\"Error\", function() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be an error\" };\n\n    this.have.instanceOf(Error);\n  });\n\n  /**\n   * Assert given object is a date\n   * @name Date\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add(\"Date\", function() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be a date\" };\n\n    this.have.instanceOf(Date);\n  });\n\n  /**\n   * Assert given object is null\n   * @name null\n   * @alias Assertion#Null\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add(\"null\", function() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be null\" };\n\n    this.assert(this.obj === null);\n  });\n\n  Assertion.alias(\"null\", \"Null\");\n\n  /**\n   * Assert given object has some internal [[Class]], via Object.prototype.toString call\n   * @name class\n   * @alias Assertion#Class\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add(\"class\", function(cls) {\n    this.params = { operator: \"to have [[Class]] \" + cls };\n\n    this.assert(Object.prototype.toString.call(this.obj) === \"[object \" + cls + \"]\");\n  });\n\n  Assertion.alias(\"class\", \"Class\");\n\n  /**\n   * Assert given object is undefined\n   * @name undefined\n   * @alias Assertion#Undefined\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add(\"undefined\", function() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be undefined\" };\n\n    this.assert(this.obj === void 0);\n  });\n\n  Assertion.alias(\"undefined\", \"Undefined\");\n\n  /**\n   * Assert given object supports es6 iterable protocol (just check\n   * that object has property Symbol.iterator, which is a function)\n   * @name iterable\n   * @memberOf Assertion\n   * @category assertion es6\n   */\n  Assertion.add(\"iterable\", function() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be iterable\" };\n\n    should(this.obj)\n      .have.property(Symbol.iterator)\n      .which.is.a.Function();\n  });\n\n  /**\n   * Assert given object supports es6 iterator protocol (just check\n   * that object has property next, which is a function)\n   * @name iterator\n   * @memberOf Assertion\n   * @category assertion es6\n   */\n  Assertion.add(\"iterator\", function() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be iterator\" };\n\n    should(this.obj)\n      .have.property(\"next\")\n      .which.is.a.Function();\n  });\n\n  /**\n   * Assert given object is a generator object\n   * @name generator\n   * @memberOf Assertion\n   * @category assertion es6\n   */\n  Assertion.add(\"generator\", function() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be generator\" };\n\n    should(this.obj).be.iterable.and.iterator.and.it.is.equal(this.obj[Symbol.iterator]());\n  });\n}\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2017 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nfunction formatEqlResult(r, a, b) {\n  return ((r.path.length > 0\n    ? \"at \" + r.path.map(formatProp).join(\" -> \")\n    : \"\") +\n    (r.a === a ? \"\" : \", A has \" + format(r.a)) +\n    (r.b === b ? \"\" : \" and B has \" + format(r.b)) +\n    (r.showReason ? \" because \" + r.reason : \"\")).trim();\n}\n\nfunction equalityAssertions(should, Assertion) {\n  /**\n   * Deep object equality comparison. For full spec see [`should-equal tests`](https://github.com/shouldjs/equal/blob/master/test.js).\n   *\n   * @name eql\n   * @memberOf Assertion\n   * @category assertion equality\n   * @alias Assertion#eqls\n   * @alias Assertion#deepEqual\n   * @param {*} val Expected value\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (10).should.be.eql(10);\n   * ('10').should.not.be.eql(10);\n   * (-0).should.not.be.eql(+0);\n   *\n   * NaN.should.be.eql(NaN);\n   *\n   * ({ a: 10}).should.be.eql({ a: 10 });\n   * [ 'a' ].should.not.be.eql({ '0': 'a' });\n   */\n  Assertion.add(\"eql\", function(val, description) {\n    this.params = { operator: \"to equal\", expected: val, message: description };\n    var obj = this.obj;\n    var fails = eql(this.obj, val, should.config);\n    this.params.details = fails\n      .map(function(fail) {\n        return formatEqlResult(fail, obj, val);\n      })\n      .join(\", \");\n\n    this.params.showDiff = eql(getType(obj), getType(val)).length === 0;\n\n    this.assert(fails.length === 0);\n  });\n\n  /**\n   * Exact comparison using ===.\n   *\n   * @name equal\n   * @memberOf Assertion\n   * @category assertion equality\n   * @alias Assertion#equals\n   * @alias Assertion#exactly\n   * @param {*} val Expected value\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * 10.should.be.equal(10);\n   * 'a'.should.be.exactly('a');\n   *\n   * should(null).be.exactly(null);\n   */\n  Assertion.add(\"equal\", function(val, description) {\n    this.params = { operator: \"to be\", expected: val, message: description };\n\n    this.params.showDiff = eql(getType(this.obj), getType(val)).length === 0;\n\n    this.assert(val === this.obj);\n  });\n\n  Assertion.alias(\"equal\", \"equals\");\n  Assertion.alias(\"equal\", \"exactly\");\n  Assertion.alias(\"eql\", \"eqls\");\n  Assertion.alias(\"eql\", \"deepEqual\");\n\n  function addOneOf(name, message, method) {\n    Assertion.add(name, function(vals) {\n      if (arguments.length !== 1) {\n        vals = Array.prototype.slice.call(arguments);\n      } else {\n        should(vals).be.Array();\n      }\n\n      this.params = { operator: message, expected: vals };\n\n      var obj = this.obj;\n      var found = false;\n\n      shouldTypeAdaptors.forEach(vals, function(val) {\n        try {\n          should(val)[method](obj);\n          found = true;\n          return false;\n        } catch (e) {\n          if (e instanceof should.AssertionError) {\n            return; //do nothing\n          }\n          throw e;\n        }\n      });\n\n      this.assert(found);\n    });\n  }\n\n  /**\n   * Exact comparison using === to be one of supplied objects.\n   *\n   * @name equalOneOf\n   * @memberOf Assertion\n   * @category assertion equality\n   * @param {Array|*} vals Expected values\n   * @example\n   *\n   * 'ab'.should.be.equalOneOf('a', 10, 'ab');\n   * 'ab'.should.be.equalOneOf(['a', 10, 'ab']);\n   */\n  addOneOf(\"equalOneOf\", \"to be equals one of\", \"equal\");\n\n  /**\n   * Exact comparison using .eql to be one of supplied objects.\n   *\n   * @name oneOf\n   * @memberOf Assertion\n   * @category assertion equality\n   * @param {Array|*} vals Expected values\n   * @example\n   *\n   * ({a: 10}).should.be.oneOf('a', 10, 'ab', {a: 10});\n   * ({a: 10}).should.be.oneOf(['a', 10, 'ab', {a: 10}]);\n   */\n  addOneOf(\"oneOf\", \"to be one of\", \"eql\");\n}\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2017 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nfunction promiseAssertions(should, Assertion$$1) {\n  /**\n   * Assert given object is a Promise\n   *\n   * @name Promise\n   * @memberOf Assertion\n   * @category assertion promises\n   * @example\n   *\n   * promise.should.be.Promise()\n   * (new Promise(function(resolve, reject) { resolve(10); })).should.be.a.Promise()\n   * (10).should.not.be.a.Promise()\n   */\n  Assertion$$1.add(\"Promise\", function() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be promise\" };\n\n    var obj = this.obj;\n\n    should(obj)\n      .have.property(\"then\")\n      .which.is.a.Function();\n  });\n\n  /**\n   * Assert given promise will be fulfilled. Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name fulfilled\n   * @memberOf Assertion\n   * @alias Assertion#resolved\n   * @returns {Promise}\n   * @category assertion promises\n   * @example\n   *\n   * // don't forget to handle async nature\n   * (new Promise(function(resolve, reject) { resolve(10); })).should.be.fulfilled();\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise(resolve => resolve(10))\n   *      .should.be.fulfilled();\n   * });\n   */\n  Assertion$$1.prototype.fulfilled = function Assertion$fulfilled() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be fulfilled\" };\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(\n      function next$onResolve(value) {\n        if (that.negate) {\n          that.fail();\n        }\n        return value;\n      },\n      function next$onReject(err) {\n        if (!that.negate) {\n          that.params.operator += \", but it was rejected with \" + should.format(err);\n          that.fail();\n        }\n        return err;\n      }\n    );\n  };\n\n  Assertion$$1.prototype.resolved = Assertion$$1.prototype.fulfilled;\n\n  /**\n   * Assert given promise will be rejected. Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name rejected\n   * @memberOf Assertion\n   * @category assertion promises\n   * @returns {Promise}\n   * @example\n   *\n   * // don't forget to handle async nature\n   * (new Promise(function(resolve, reject) { resolve(10); }))\n   *    .should.not.be.rejected();\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise((resolve, reject) => reject(new Error('boom')))\n   *      .should.be.rejected();\n   * });\n   */\n  Assertion$$1.prototype.rejected = function() {\n    this.assertZeroArguments(arguments);\n    this.params = { operator: \"to be rejected\" };\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(\n      function(value) {\n        if (!that.negate) {\n          that.params.operator += \", but it was fulfilled\";\n          if (arguments.length != 0) {\n            that.params.operator += \" with \" + should.format(value);\n          }\n          that.fail();\n        }\n        return value;\n      },\n      function next$onError(err) {\n        if (that.negate) {\n          that.fail();\n        }\n        return err;\n      }\n    );\n  };\n\n  /**\n   * Assert given promise will be fulfilled with some expected value (value compared using .eql).\n   * Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name fulfilledWith\n   * @memberOf Assertion\n   * @alias Assertion#resolvedWith\n   * @category assertion promises\n   * @returns {Promise}\n   * @example\n   *\n   * // don't forget to handle async nature\n   * (new Promise(function(resolve, reject) { resolve(10); }))\n   *    .should.be.fulfilledWith(10);\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise((resolve, reject) => resolve(10))\n   *       .should.be.fulfilledWith(10);\n   * });\n   */\n  Assertion$$1.prototype.fulfilledWith = function(expectedValue) {\n    this.params = {\n      operator: \"to be fulfilled with \" + should.format(expectedValue)\n    };\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(\n      function(value) {\n        if (that.negate) {\n          that.fail();\n        }\n        should(value).eql(expectedValue);\n        return value;\n      },\n      function next$onError(err) {\n        if (!that.negate) {\n          that.params.operator += \", but it was rejected with \" + should.format(err);\n          that.fail();\n        }\n        return err;\n      }\n    );\n  };\n\n  Assertion$$1.prototype.resolvedWith = Assertion$$1.prototype.fulfilledWith;\n\n  /**\n   * Assert given promise will be rejected with some sort of error. Arguments is the same for Assertion#throw.\n   * Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name rejectedWith\n   * @memberOf Assertion\n   * @category assertion promises\n   * @returns {Promise}\n   * @example\n   *\n   * function failedPromise() {\n   *   return new Promise(function(resolve, reject) {\n   *     reject(new Error('boom'))\n   *   })\n   * }\n   * failedPromise().should.be.rejectedWith(Error);\n   * failedPromise().should.be.rejectedWith('boom');\n   * failedPromise().should.be.rejectedWith(/boom/);\n   * failedPromise().should.be.rejectedWith(Error, { message: 'boom' });\n   * failedPromise().should.be.rejectedWith({ message: 'boom' });\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return failedPromise().should.be.rejectedWith({ message: 'boom' });\n   * });\n   */\n  Assertion$$1.prototype.rejectedWith = function(message, properties) {\n    this.params = { operator: \"to be rejected\" };\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(\n      function(value) {\n        if (!that.negate) {\n          that.fail();\n        }\n        return value;\n      },\n      function next$onError(err) {\n        if (that.negate) {\n          that.fail();\n        }\n\n        var errorMatched = true;\n        var errorInfo = \"\";\n\n        if (\"string\" === typeof message) {\n          errorMatched = message === err.message;\n        } else if (message instanceof RegExp) {\n          errorMatched = message.test(err.message);\n        } else if (\"function\" === typeof message) {\n          errorMatched = err instanceof message;\n        } else if (message !== null && typeof message === \"object\") {\n          try {\n            should(err).match(message);\n          } catch (e) {\n            if (e instanceof should.AssertionError) {\n              errorInfo = \": \" + e.message;\n              errorMatched = false;\n            } else {\n              throw e;\n            }\n          }\n        }\n\n        if (!errorMatched) {\n          if (typeof message === \"string\" || message instanceof RegExp) {\n            errorInfo = \" with a message matching \" + should.format(message) + \", but got '\" + err.message + \"'\";\n          } else if (\"function\" === typeof message) {\n            errorInfo = \" of type \" + functionName(message) + \", but got \" + functionName(err.constructor);\n          }\n        } else if (\"function\" === typeof message && properties) {\n          try {\n            should(err).match(properties);\n          } catch (e) {\n            if (e instanceof should.AssertionError) {\n              errorInfo = \": \" + e.message;\n              errorMatched = false;\n            } else {\n              throw e;\n            }\n          }\n        }\n\n        that.params.operator += errorInfo;\n\n        that.assert(errorMatched);\n\n        return err;\n      }\n    );\n  };\n\n  /**\n   * Assert given object is promise and wrap it in PromisedAssertion, which has all properties of Assertion.\n   * That means you can chain as with usual Assertion.\n   * Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name finally\n   * @memberOf Assertion\n   * @alias Assertion#eventually\n   * @category assertion promises\n   * @returns {PromisedAssertion} Like Assertion, but .then this.obj in Assertion\n   * @example\n   *\n   * (new Promise(function(resolve, reject) { resolve(10); }))\n   *    .should.be.eventually.equal(10);\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise(resolve => resolve(10))\n   *      .should.be.finally.equal(10);\n   * });\n   */\n  Object.defineProperty(Assertion$$1.prototype, \"finally\", {\n    get: function() {\n      should(this.obj).be.a.Promise();\n\n      var that = this;\n\n      return new PromisedAssertion(\n        this.obj.then(function(obj) {\n          var a = should(obj);\n\n          a.negate = that.negate;\n          a.anyOne = that.anyOne;\n\n          return a;\n        })\n      );\n    }\n  });\n\n  Assertion$$1.alias(\"finally\", \"eventually\");\n}\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2017 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nfunction stringAssertions(should, Assertion) {\n  /**\n   * Assert given string starts with prefix\n   * @name startWith\n   * @memberOf Assertion\n   * @category assertion strings\n   * @param {string} str Prefix\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * 'abc'.should.startWith('a');\n   */\n  Assertion.add(\"startWith\", function(str, description) {\n    this.params = {\n      operator: \"to start with \" + should.format(str),\n      message: description\n    };\n\n    this.assert(0 === this.obj.indexOf(str));\n  });\n\n  /**\n   * Assert given string ends with prefix\n   * @name endWith\n   * @memberOf Assertion\n   * @category assertion strings\n   * @param {string} str Prefix\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * 'abca'.should.endWith('a');\n   */\n  Assertion.add(\"endWith\", function(str, description) {\n    this.params = {\n      operator: \"to end with \" + should.format(str),\n      message: description\n    };\n\n    this.assert(this.obj.indexOf(str, this.obj.length - str.length) >= 0);\n  });\n}\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2017 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nfunction containAssertions(should, Assertion) {\n  var i = should.format;\n\n  /**\n   * Assert that given object contain something that equal to `other`. It uses `should-equal` for equality checks.\n   * If given object is array it search that one of elements was equal to `other`.\n   * If given object is string it checks if `other` is a substring - expected that `other` is a string.\n   * If given object is Object it checks that `other` is a subobject - expected that `other` is a object.\n   *\n   * @name containEql\n   * @memberOf Assertion\n   * @category assertion contain\n   * @param {*} other Nested object\n   * @example\n   *\n   * [1, 2, 3].should.containEql(1);\n   * [{ a: 1 }, 'a', 10].should.containEql({ a: 1 });\n   *\n   * 'abc'.should.containEql('b');\n   * 'ab1c'.should.containEql(1);\n   *\n   * ({ a: 10, c: { d: 10 }}).should.containEql({ a: 10 });\n   * ({ a: 10, c: { d: 10 }}).should.containEql({ c: { d: 10 }});\n   * ({ a: 10, c: { d: 10 }}).should.containEql({ b: 10 });\n   * // throws AssertionError: expected { a: 10, c: { d: 10 } } to contain { b: 10 }\n   * //            expected { a: 10, c: { d: 10 } } to have property b\n   */\n  Assertion.add(\"containEql\", function(other) {\n    this.params = { operator: \"to contain \" + i(other) };\n\n    this.is.not.null().and.not.undefined();\n\n    var obj = this.obj;\n\n    if (typeof obj == \"string\") {\n      this.assert(obj.indexOf(String(other)) >= 0);\n    } else if (shouldTypeAdaptors.isIterable(obj)) {\n      this.assert(\n        shouldTypeAdaptors.some(obj, function(v) {\n          return eql(v, other).length === 0;\n        })\n      );\n    } else {\n      shouldTypeAdaptors.forEach(\n        other,\n        function(value, key) {\n          should(obj).have.value(key, value);\n        },\n        this\n      );\n    }\n  });\n\n  /**\n   * Assert that given object is contain equally structured object on the same depth level.\n   * If given object is an array and `other` is an array it checks that the eql elements is going in the same sequence in given array (recursive)\n   * If given object is an object it checks that the same keys contain deep equal values (recursive)\n   * On other cases it try to check with `.eql`\n   *\n   * @name containDeepOrdered\n   * @memberOf Assertion\n   * @category assertion contain\n   * @param {*} other Nested object\n   * @example\n   *\n   * [ 1, 2, 3].should.containDeepOrdered([1, 2]);\n   * [ 1, 2, [ 1, 2, 3 ]].should.containDeepOrdered([ 1, [ 2, 3 ]]);\n   *\n   * ({ a: 10, b: { c: 10, d: [1, 2, 3] }}).should.containDeepOrdered({a: 10});\n   * ({ a: 10, b: { c: 10, d: [1, 2, 3] }}).should.containDeepOrdered({b: {c: 10}});\n   * ({ a: 10, b: { c: 10, d: [1, 2, 3] }}).should.containDeepOrdered({b: {d: [1, 3]}});\n   */\n  Assertion.add(\"containDeepOrdered\", function(other) {\n    this.params = { operator: \"to contain \" + i(other) };\n\n    var obj = this.obj;\n    if (typeof obj == \"string\") {\n      // expect other to be string\n      this.is.equal(String(other));\n    } else if (shouldTypeAdaptors.isIterable(obj) && shouldTypeAdaptors.isIterable(other)) {\n      var objIterator = shouldTypeAdaptors.iterator(obj);\n      var otherIterator = shouldTypeAdaptors.iterator(other);\n\n      var nextObj = objIterator.next();\n      var nextOther = otherIterator.next();\n      while (!nextObj.done && !nextOther.done) {\n        try {\n          should(nextObj.value[1]).containDeepOrdered(nextOther.value[1]);\n          nextOther = otherIterator.next();\n        } catch (e) {\n          if (!(e instanceof should.AssertionError)) {\n            throw e;\n          }\n        }\n        nextObj = objIterator.next();\n      }\n\n      this.assert(nextOther.done);\n    } else if (obj != null && typeof obj == \"object\" && other != null && typeof other == \"object\") {\n      //TODO compare types object contains object case\n      shouldTypeAdaptors.forEach(other, function(value, key) {\n        should(obj[key]).containDeepOrdered(value);\n      });\n\n      // if both objects is empty means we finish traversing - and we need to compare for hidden values\n      if (shouldTypeAdaptors.isEmpty(other)) {\n        this.eql(other);\n      }\n    } else {\n      this.eql(other);\n    }\n  });\n\n  /**\n   * The same like `Assertion#containDeepOrdered` but all checks on arrays without order.\n   *\n   * @name containDeep\n   * @memberOf Assertion\n   * @category assertion contain\n   * @param {*} other Nested object\n   * @example\n   *\n   * [ 1, 2, 3].should.containDeep([2, 1]);\n   * [ 1, 2, [ 1, 2, 3 ]].should.containDeep([ 1, [ 3, 1 ]]);\n   */\n  Assertion.add(\"containDeep\", function(other) {\n    this.params = { operator: \"to contain \" + i(other) };\n\n    var obj = this.obj;\n    if (typeof obj === \"string\" && typeof other === \"string\") {\n      // expect other to be string\n      this.is.equal(String(other));\n    } else if (shouldTypeAdaptors.isIterable(obj) && shouldTypeAdaptors.isIterable(other)) {\n      var usedKeys = {};\n      shouldTypeAdaptors.forEach(\n        other,\n        function(otherItem) {\n          this.assert(\n            shouldTypeAdaptors.some(obj, function(item, index) {\n              if (index in usedKeys) {\n                return false;\n              }\n\n              try {\n                should(item).containDeep(otherItem);\n                usedKeys[index] = true;\n                return true;\n              } catch (e) {\n                if (e instanceof should.AssertionError) {\n                  return false;\n                }\n                throw e;\n              }\n            })\n          );\n        },\n        this\n      );\n    } else if (obj != null && other != null && typeof obj == \"object\" && typeof other == \"object\") {\n      // object contains object case\n      shouldTypeAdaptors.forEach(other, function(value, key) {\n        should(obj[key]).containDeep(value);\n      });\n\n      // if both objects is empty means we finish traversing - and we need to compare for hidden values\n      if (shouldTypeAdaptors.isEmpty(other)) {\n        this.eql(other);\n      }\n    } else {\n      this.eql(other);\n    }\n  });\n}\n\n/*\r\n * should.js - assertion library\r\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\r\n * Copyright(c) 2013-2017 Denis Bardadym <bardadymchik@gmail.com>\r\n * MIT Licensed\r\n */\r\n\r\nvar aSlice = Array.prototype.slice;\r\n\r\nfunction propertyAssertions(should, Assertion) {\r\n  var i = should.format;\r\n  /**\r\n   * Asserts given object has some descriptor. **On success it change given object to be value of property**.\r\n   *\r\n   * @name propertyWithDescriptor\r\n   * @memberOf Assertion\r\n   * @category assertion property\r\n   * @param {string} name Name of property\r\n   * @param {Object} desc Descriptor like used in Object.defineProperty (not required to add all properties)\r\n   * @example\r\n   *\r\n   * ({ a: 10 }).should.have.propertyWithDescriptor('a', { enumerable: true });\r\n   */\r\n  Assertion.add(\"propertyWithDescriptor\", function(name, desc) {\r\n    this.params = {\r\n      actual: this.obj,\r\n      operator: \"to have own property with descriptor \" + i(desc)\r\n    };\r\n    var obj = this.obj;\r\n    this.have.ownProperty(name);\r\n    should(Object.getOwnPropertyDescriptor(Object(obj), name)).have.properties(desc);\r\n  });\r\n\r\n  /**\r\n   * Asserts given object has property with optionally value. **On success it change given object to be value of property**.\r\n   *\r\n   * @name property\r\n   * @memberOf Assertion\r\n   * @category assertion property\r\n   * @param {string} name Name of property\r\n   * @param {*} [val] Optional property value to check\r\n   * @example\r\n   *\r\n   * ({ a: 10 }).should.have.property('a');\r\n   */\r\n  Assertion.add(\"property\", function(name, val) {\r\n    name = convertPropertyName(name);\r\n    if (arguments.length > 1) {\r\n      var p = {};\r\n      p[name] = val;\r\n      this.have.properties(p);\r\n    } else {\r\n      this.have.properties(name);\r\n    }\r\n    this.obj = this.obj[name];\r\n  });\r\n\r\n  /**\r\n   * Asserts given object has properties. On this method affect .any modifier, which allow to check not all properties.\r\n   *\r\n   * @name properties\r\n   * @memberOf Assertion\r\n   * @category assertion property\r\n   * @param {Array|...string|Object} names Names of property\r\n   * @example\r\n   *\r\n   * ({ a: 10 }).should.have.properties('a');\r\n   * ({ a: 10, b: 20 }).should.have.properties([ 'a' ]);\r\n   * ({ a: 10, b: 20 }).should.have.properties({ b: 20 });\r\n   */\r\n  Assertion.add(\"properties\", function(names) {\r\n    var values = {};\r\n    if (arguments.length > 1) {\r\n      names = aSlice.call(arguments);\r\n    } else if (!Array.isArray(names)) {\r\n      if (typeof names == \"string\" || typeof names == \"symbol\") {\r\n        names = [names];\r\n      } else {\r\n        values = names;\r\n        names = Object.keys(names);\r\n      }\r\n    }\r\n\r\n    var obj = Object(this.obj),\r\n      missingProperties = [];\r\n\r\n    //just enumerate properties and check if they all present\r\n    names.forEach(function(name) {\r\n      if (!(name in obj)) {\r\n        missingProperties.push(formatProp(name));\r\n      }\r\n    });\r\n\r\n    var props = missingProperties;\r\n    if (props.length === 0) {\r\n      props = names.map(formatProp);\r\n    } else if (this.anyOne) {\r\n      props = names\r\n        .filter(function(name) {\r\n          return missingProperties.indexOf(formatProp(name)) < 0;\r\n        })\r\n        .map(formatProp);\r\n    }\r\n\r\n    var operator =\r\n      (props.length === 1\r\n        ? \"to have property \"\r\n        : \"to have \" + (this.anyOne ? \"any of \" : \"\") + \"properties \") + props.join(\", \");\r\n\r\n    this.params = { obj: this.obj, operator: operator };\r\n\r\n    //check that all properties presented\r\n    //or if we request one of them that at least one them presented\r\n    this.assert(\r\n      missingProperties.length === 0 || (this.anyOne && missingProperties.length != names.length)\r\n    );\r\n\r\n    // check if values in object matched expected\r\n    var valueCheckNames = Object.keys(values);\r\n    if (valueCheckNames.length) {\r\n      var wrongValues = [];\r\n      props = [];\r\n\r\n      // now check values, as there we have all properties\r\n      valueCheckNames.forEach(function(name) {\r\n        var value = values[name];\r\n        if (eql(obj[name], value).length !== 0) {\r\n          wrongValues.push(formatProp(name) + \" of \" + i(value) + \" (got \" + i(obj[name]) + \")\");\r\n        } else {\r\n          props.push(formatProp(name) + \" of \" + i(value));\r\n        }\r\n      });\r\n\r\n      if ((wrongValues.length !== 0 && !this.anyOne) || (this.anyOne && props.length === 0)) {\r\n        props = wrongValues;\r\n      }\r\n\r\n      operator =\r\n        (props.length === 1\r\n          ? \"to have property \"\r\n          : \"to have \" + (this.anyOne ? \"any of \" : \"\") + \"properties \") + props.join(\", \");\r\n\r\n      this.params = { obj: this.obj, operator: operator };\r\n\r\n      //if there is no not matched values\r\n      //or there is at least one matched\r\n      this.assert(\r\n        wrongValues.length === 0 || (this.anyOne && wrongValues.length != valueCheckNames.length)\r\n      );\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Asserts given object has property `length` with given value `n`\r\n   *\r\n   * @name length\r\n   * @alias Assertion#lengthOf\r\n   * @memberOf Assertion\r\n   * @category assertion property\r\n   * @param {number} n Expected length\r\n   * @param {string} [description] Optional message\r\n   * @example\r\n   *\r\n   * [1, 2].should.have.length(2);\r\n   */\r\n  Assertion.add(\"length\", function(n, description) {\r\n    this.have.property(\"length\", n, description);\r\n  });\r\n\r\n  Assertion.alias(\"length\", \"lengthOf\");\r\n\r\n  /**\r\n   * Asserts given object has own property. **On success it change given object to be value of property**.\r\n   *\r\n   * @name ownProperty\r\n   * @alias Assertion#hasOwnProperty\r\n   * @memberOf Assertion\r\n   * @category assertion property\r\n   * @param {string} name Name of property\r\n   * @param {string} [description] Optional message\r\n   * @example\r\n   *\r\n   * ({ a: 10 }).should.have.ownProperty('a');\r\n   */\r\n  Assertion.add(\"ownProperty\", function(name, description) {\r\n    name = convertPropertyName(name);\r\n    this.params = {\r\n      actual: this.obj,\r\n      operator: \"to have own property \" + formatProp(name),\r\n      message: description\r\n    };\r\n\r\n    this.assert(shouldUtil.hasOwnProperty(this.obj, name));\r\n\r\n    this.obj = this.obj[name];\r\n  });\r\n\r\n  Assertion.alias(\"ownProperty\", \"hasOwnProperty\");\r\n\r\n  /**\r\n   * Asserts given object is empty. For strings, arrays and arguments it checks .length property, for objects it checks keys.\r\n   *\r\n   * @name empty\r\n   * @memberOf Assertion\r\n   * @category assertion property\r\n   * @example\r\n   *\r\n   * ''.should.be.empty();\r\n   * [].should.be.empty();\r\n   * ({}).should.be.empty();\r\n   */\r\n  Assertion.add(\r\n    \"empty\",\r\n    function() {\r\n      this.params = { operator: \"to be empty\" };\r\n      this.assert(shouldTypeAdaptors.isEmpty(this.obj));\r\n    },\r\n    true\r\n  );\r\n\r\n  /**\r\n   * Asserts given object has such keys. Compared to `properties`, `keys` does not accept Object as a argument.\r\n   * When calling via .key current object in assertion changed to value of this key\r\n   *\r\n   * @name keys\r\n   * @alias Assertion#key\r\n   * @memberOf Assertion\r\n   * @category assertion property\r\n   * @param {...*} keys Keys to check\r\n   * @example\r\n   *\r\n   * ({ a: 10 }).should.have.keys('a');\r\n   * ({ a: 10, b: 20 }).should.have.keys('a', 'b');\r\n   * (new Map([[1, 2]])).should.have.key(1);\r\n   *\r\n   * json.should.have.only.keys('type', 'version')\r\n   */\r\n  Assertion.add(\"keys\", function(keys) {\r\n    keys = aSlice.call(arguments);\r\n\r\n    var obj = Object(this.obj);\r\n\r\n    // first check if some keys are missing\r\n    var missingKeys = keys.filter(function(key) {\r\n      return !shouldTypeAdaptors.has(obj, key);\r\n    });\r\n\r\n    var verb = \"to have \" + (this.onlyThis ? \"only \" : \"\") + (keys.length === 1 ? \"key \" : \"keys \");\r\n\r\n    this.params = { operator: verb + keys.join(\", \") };\r\n\r\n    if (missingKeys.length > 0) {\r\n      this.params.operator += \"\\n\\tmissing keys: \" + missingKeys.join(\", \");\r\n    }\r\n\r\n    this.assert(missingKeys.length === 0);\r\n\r\n    if (this.onlyThis) {\r\n      should(obj).have.size(keys.length);\r\n    }\r\n  });\r\n\r\n  Assertion.add(\"key\", function(key) {\r\n    this.have.keys(key);\r\n    this.obj = shouldTypeAdaptors.get(this.obj, key);\r\n  });\r\n\r\n  /**\r\n   * Asserts given object has such value for given key\r\n   *\r\n   * @name value\r\n   * @memberOf Assertion\r\n   * @category assertion property\r\n   * @param {*} key Key to check\r\n   * @param {*} value Value to check\r\n   * @example\r\n   *\r\n   * ({ a: 10 }).should.have.value('a', 10);\r\n   * (new Map([[1, 2]])).should.have.value(1, 2);\r\n   */\r\n  Assertion.add(\"value\", function(key, value) {\r\n    this.have.key(key).which.is.eql(value);\r\n  });\r\n\r\n  /**\r\n   * Asserts given object has such size.\r\n   *\r\n   * @name size\r\n   * @memberOf Assertion\r\n   * @category assertion property\r\n   * @param {number} s Size to check\r\n   * @example\r\n   *\r\n   * ({ a: 10 }).should.have.size(1);\r\n   * (new Map([[1, 2]])).should.have.size(1);\r\n   */\r\n  Assertion.add(\"size\", function(s) {\r\n    this.params = { operator: \"to have size \" + s };\r\n    should(shouldTypeAdaptors.size(this.obj)).be.exactly(s);\r\n  });\r\n\r\n  /**\r\n   * Asserts given object has nested property in depth by path. **On success it change given object to be value of final property**.\r\n   *\r\n   * @name propertyByPath\r\n   * @memberOf Assertion\r\n   * @category assertion property\r\n   * @param {Array|...string} properties Properties path to search\r\n   * @example\r\n   *\r\n   * ({ a: {b: 10}}).should.have.propertyByPath('a', 'b').eql(10);\r\n   */\r\n  Assertion.add(\"propertyByPath\", function(properties) {\r\n    properties = aSlice.call(arguments);\r\n\r\n    var allProps = properties.map(formatProp);\r\n\r\n    properties = properties.map(convertPropertyName);\r\n\r\n    var obj = should(Object(this.obj));\r\n\r\n    var foundProperties = [];\r\n\r\n    var currentProperty;\r\n    while (properties.length) {\r\n      currentProperty = properties.shift();\r\n      this.params = {\r\n        operator:\r\n          \"to have property by path \" +\r\n          allProps.join(\", \") +\r\n          \" - failed on \" +\r\n          formatProp(currentProperty)\r\n      };\r\n      obj = obj.have.property(currentProperty);\r\n      foundProperties.push(currentProperty);\r\n    }\r\n\r\n    this.params = {\r\n      obj: this.obj,\r\n      operator: \"to have property by path \" + allProps.join(\", \")\r\n    };\r\n\r\n    this.obj = obj.obj;\r\n  });\r\n}\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2017 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\nfunction errorAssertions(should, Assertion) {\n  var i = should.format;\n\n  /**\n   * Assert given function throws error with such message.\n   *\n   * @name throw\n   * @memberOf Assertion\n   * @category assertion errors\n   * @alias Assertion#throwError\n   * @param {string|RegExp|Function|Object|GeneratorFunction|GeneratorObject} [message] Message to match or properties\n   * @param {Object} [properties] Optional properties that will be matched to thrown error\n   * @example\n   *\n   * (function(){ throw new Error('fail') }).should.throw();\n   * (function(){ throw new Error('fail') }).should.throw('fail');\n   * (function(){ throw new Error('fail') }).should.throw(/fail/);\n   *\n   * (function(){ throw new Error('fail') }).should.throw(Error);\n   * var error = new Error();\n   * error.a = 10;\n   * (function(){ throw error; }).should.throw(Error, { a: 10 });\n   * (function(){ throw error; }).should.throw({ a: 10 });\n   * (function*() {\n   *   yield throwError();\n   * }).should.throw();\n   */\n  Assertion.add(\"throw\", function(message, properties) {\n    var fn = this.obj;\n    var err = {};\n    var errorInfo = \"\";\n    var thrown = false;\n\n    if (shouldUtil.isGeneratorFunction(fn)) {\n      return should(fn()).throw(message, properties);\n    } else if (shouldUtil.isIterator(fn)) {\n      return should(fn.next.bind(fn)).throw(message, properties);\n    }\n\n    this.is.a.Function();\n\n    var errorMatched = true;\n\n    try {\n      fn();\n    } catch (e) {\n      thrown = true;\n      err = e;\n    }\n\n    if (thrown) {\n      if (message) {\n        if (\"string\" == typeof message) {\n          errorMatched = message == err.message;\n        } else if (message instanceof RegExp) {\n          errorMatched = message.test(err.message);\n        } else if (\"function\" == typeof message) {\n          errorMatched = err instanceof message;\n        } else if (null != message) {\n          try {\n            should(err).match(message);\n          } catch (e) {\n            if (e instanceof should.AssertionError) {\n              errorInfo = \": \" + e.message;\n              errorMatched = false;\n            } else {\n              throw e;\n            }\n          }\n        }\n\n        if (!errorMatched) {\n          if (\"string\" == typeof message || message instanceof RegExp) {\n            errorInfo =\n              \" with a message matching \" +\n              i(message) +\n              \", but got '\" +\n              err.message +\n              \"'\";\n          } else if (\"function\" == typeof message) {\n            errorInfo =\n              \" of type \" +\n              functionName(message) +\n              \", but got \" +\n              functionName(err.constructor);\n          }\n        } else if (\"function\" == typeof message && properties) {\n          try {\n            should(err).match(properties);\n          } catch (e) {\n            if (e instanceof should.AssertionError) {\n              errorInfo = \": \" + e.message;\n              errorMatched = false;\n            } else {\n              throw e;\n            }\n          }\n        }\n      } else {\n        errorInfo = \" (got \" + i(err) + \")\";\n      }\n    }\n\n    this.params = { operator: \"to throw exception\" + errorInfo };\n\n    this.assert(thrown);\n    this.assert(errorMatched);\n  });\n\n  Assertion.alias(\"throw\", \"throwError\");\n}\n\n/*\r\n * should.js - assertion library\r\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\r\n * Copyright(c) 2013-2017 Denis Bardadym <bardadymchik@gmail.com>\r\n * MIT Licensed\r\n */\r\n\r\nfunction matchingAssertions(should, Assertion) {\r\n  var i = should.format;\r\n\r\n  /**\r\n   * Asserts if given object match `other` object, using some assumptions:\r\n   * First object matched if they are equal,\r\n   * If `other` is a regexp and given object is a string check on matching with regexp\r\n   * If `other` is a regexp and given object is an array check if all elements matched regexp\r\n   * If `other` is a regexp and given object is an object check values on matching regexp\r\n   * If `other` is a function check if this function throws AssertionError on given object or return false - it will be assumed as not matched\r\n   * If `other` is an object check if the same keys matched with above rules\r\n   * All other cases failed.\r\n   *\r\n   * Usually it is right idea to add pre type assertions, like `.String()` or `.Object()` to be sure assertions will do what you are expecting.\r\n   * Object iteration happen by keys (properties with enumerable: true), thus some objects can cause small pain. Typical example is js\r\n   * Error - it by default has 2 properties `name` and `message`, but they both non-enumerable. In this case make sure you specify checking props (see examples).\r\n   *\r\n   * @name match\r\n   * @memberOf Assertion\r\n   * @category assertion matching\r\n   * @param {*} other Object to match\r\n   * @param {string} [description] Optional message\r\n   * @example\r\n   * 'foobar'.should.match(/^foo/);\r\n   * 'foobar'.should.not.match(/^bar/);\r\n   *\r\n   * ({ a: 'foo', c: 'barfoo' }).should.match(/foo$/);\r\n   *\r\n   * ['a', 'b', 'c'].should.match(/[a-z]/);\r\n   *\r\n   * (5).should.not.match(function(n) {\r\n   *   return n < 0;\r\n   * });\r\n   * (5).should.not.match(function(it) {\r\n   *    it.should.be.an.Array();\r\n   * });\r\n   * ({ a: 10, b: 'abc', c: { d: 10 }, d: 0 }).should\r\n   * .match({ a: 10, b: /c$/, c: function(it) {\r\n   *    return it.should.have.property('d', 10);\r\n   * }});\r\n   *\r\n   * [10, 'abc', { d: 10 }, 0].should\r\n   * .match({ '0': 10, '1': /c$/, '2': function(it) {\r\n   *    return it.should.have.property('d', 10);\r\n   * }});\r\n   *\r\n   * var myString = 'abc';\r\n   *\r\n   * myString.should.be.a.String().and.match(/abc/);\r\n   *\r\n   * myString = {};\r\n   *\r\n   * myString.should.match(/abc/); //yes this will pass\r\n   * //better to do\r\n   * myString.should.be.an.Object().and.not.empty().and.match(/abc/);//fixed\r\n   *\r\n   * (new Error('boom')).should.match(/abc/);//passed because no keys\r\n   * (new Error('boom')).should.not.match({ message: /abc/ });//check specified property\r\n   */\r\n  Assertion.add(\"match\", function(other, description) {\r\n    this.params = { operator: \"to match \" + i(other), message: description };\r\n\r\n    if (eql(this.obj, other).length !== 0) {\r\n      if (other instanceof RegExp) {\r\n        // something - regex\r\n\r\n        if (typeof this.obj == \"string\") {\r\n          this.assert(other.exec(this.obj));\r\n        } else if (null != this.obj && typeof this.obj == \"object\") {\r\n          var notMatchedProps = [],\r\n            matchedProps = [];\r\n          shouldTypeAdaptors.forEach(\r\n            this.obj,\r\n            function(value, name) {\r\n              if (other.exec(value)) {\r\n                matchedProps.push(formatProp(name));\r\n              } else {\r\n                notMatchedProps.push(formatProp(name) + \" (\" + i(value) + \")\");\r\n              }\r\n            },\r\n            this\r\n          );\r\n\r\n          if (notMatchedProps.length) {\r\n            this.params.operator += \"\\n    not matched properties: \" + notMatchedProps.join(\", \");\r\n          }\r\n          if (matchedProps.length) {\r\n            this.params.operator += \"\\n    matched properties: \" + matchedProps.join(\", \");\r\n          }\r\n\r\n          this.assert(notMatchedProps.length === 0);\r\n        } else {\r\n          // should we try to convert to String and exec?\r\n          this.assert(false);\r\n        }\r\n      } else if (typeof other == \"function\") {\r\n        var res;\r\n\r\n        res = other(this.obj);\r\n\r\n        //if we throw exception ok - it is used .should inside\r\n        if (typeof res == \"boolean\") {\r\n          this.assert(res); // if it is just boolean function assert on it\r\n        }\r\n      } else if (typeof this.obj == \"object\" && this.obj != null && (isPlainObject(other) || Array.isArray(other))) {\r\n        // try to match properties (for Object and Array)\r\n        notMatchedProps = [];\r\n        matchedProps = [];\r\n\r\n        shouldTypeAdaptors.forEach(\r\n          other,\r\n          function(value, key) {\r\n            try {\r\n              should(this.obj)\r\n                .have.property(key)\r\n                .which.match(value);\r\n              matchedProps.push(formatProp(key));\r\n            } catch (e) {\r\n              if (e instanceof should.AssertionError) {\r\n                notMatchedProps.push(formatProp(key) + \" (\" + i(this.obj[key]) + \")\");\r\n              } else {\r\n                throw e;\r\n              }\r\n            }\r\n          },\r\n          this\r\n        );\r\n\r\n        if (notMatchedProps.length) {\r\n          this.params.operator += \"\\n    not matched properties: \" + notMatchedProps.join(\", \");\r\n        }\r\n        if (matchedProps.length) {\r\n          this.params.operator += \"\\n    matched properties: \" + matchedProps.join(\", \");\r\n        }\r\n\r\n        this.assert(notMatchedProps.length === 0);\r\n      } else {\r\n        this.assert(false);\r\n      }\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Asserts if given object values or array elements all match `other` object, using some assumptions:\r\n   * First object matched if they are equal,\r\n   * If `other` is a regexp - matching with regexp\r\n   * If `other` is a function check if this function throws AssertionError on given object or return false - it will be assumed as not matched\r\n   * All other cases check if this `other` equal to each element\r\n   *\r\n   * @name matchEach\r\n   * @memberOf Assertion\r\n   * @category assertion matching\r\n   * @alias Assertion#matchEvery\r\n   * @param {*} other Object to match\r\n   * @param {string} [description] Optional message\r\n   * @example\r\n   * [ 'a', 'b', 'c'].should.matchEach(/\\w+/);\r\n   * [ 'a', 'a', 'a'].should.matchEach('a');\r\n   *\r\n   * [ 'a', 'a', 'a'].should.matchEach(function(value) { value.should.be.eql('a') });\r\n   *\r\n   * { a: 'a', b: 'a', c: 'a' }.should.matchEach(function(value) { value.should.be.eql('a') });\r\n   */\r\n  Assertion.add(\"matchEach\", function(other, description) {\r\n    this.params = {\r\n      operator: \"to match each \" + i(other),\r\n      message: description\r\n    };\r\n\r\n    shouldTypeAdaptors.forEach(\r\n      this.obj,\r\n      function(value) {\r\n        should(value).match(other);\r\n      },\r\n      this\r\n    );\r\n  });\r\n\r\n  /**\r\n  * Asserts if any of given object values or array elements match `other` object, using some assumptions:\r\n  * First object matched if they are equal,\r\n  * If `other` is a regexp - matching with regexp\r\n  * If `other` is a function check if this function throws AssertionError on given object or return false - it will be assumed as not matched\r\n  * All other cases check if this `other` equal to each element\r\n  *\r\n  * @name matchAny\r\n  * @memberOf Assertion\r\n  * @category assertion matching\r\n  * @param {*} other Object to match\r\n  * @alias Assertion#matchSome\r\n  * @param {string} [description] Optional message\r\n  * @example\r\n  * [ 'a', 'b', 'c'].should.matchAny(/\\w+/);\r\n  * [ 'a', 'b', 'c'].should.matchAny('a');\r\n  *\r\n  * [ 'a', 'b', 'c'].should.matchAny(function(value) { value.should.be.eql('a') });\r\n  *\r\n  * { a: 'a', b: 'b', c: 'c' }.should.matchAny(function(value) { value.should.be.eql('a') });\r\n  */\r\n  Assertion.add(\"matchAny\", function(other, description) {\r\n    this.params = {\r\n      operator: \"to match any \" + i(other),\r\n      message: description\r\n    };\r\n\r\n    this.assert(\r\n      shouldTypeAdaptors.some(this.obj, function(value) {\r\n        try {\r\n          should(value).match(other);\r\n          return true;\r\n        } catch (e) {\r\n          if (e instanceof should.AssertionError) {\r\n            // Caught an AssertionError, return false to the iterator\r\n            return false;\r\n          }\r\n          throw e;\r\n        }\r\n      })\r\n    );\r\n  });\r\n\r\n  Assertion.alias(\"matchAny\", \"matchSome\");\r\n  Assertion.alias(\"matchEach\", \"matchEvery\");\r\n}\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2017 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n/**\n * Our function should\n *\n * @param {*} obj Object to assert\n * @returns {should.Assertion} Returns new Assertion for beginning assertion chain\n * @example\n *\n * var should = require('should');\n * should('abc').be.a.String();\n */\nfunction should$1(obj) {\n  return new Assertion(obj);\n}\n\nshould$1.AssertionError = AssertionError;\nshould$1.Assertion = Assertion;\n\n// exposing modules dirty way\nshould$1.modules = {\n  format: sformat,\n  type: getType,\n  equal: eql\n};\nshould$1.format = format;\n\n/**\n * Object with configuration.\n * It contains such properties:\n * * `checkProtoEql` boolean - Affect if `.eql` will check objects prototypes\n * * `plusZeroAndMinusZeroEqual` boolean - Affect if `.eql` will treat +0 and -0 as equal\n * Also it can contain options for should-format.\n *\n * @type {Object}\n * @memberOf should\n * @static\n * @example\n *\n * var a = { a: 10 }, b = Object.create(null);\n * b.a = 10;\n *\n * a.should.be.eql(b);\n * //not throws\n *\n * should.config.checkProtoEql = true;\n * a.should.be.eql(b);\n * //throws AssertionError: expected { a: 10 } to equal { a: 10 } (because A and B have different prototypes)\n */\nshould$1.config = config;\n\n/**\n * Allow to extend given prototype with should property using given name. This getter will **unwrap** all standard wrappers like `Number`, `Boolean`, `String`.\n * Using `should(obj)` is the equivalent of using `obj.should` with known issues (like nulls and method calls etc).\n *\n * To add new assertions, need to use Assertion.add method.\n *\n * @param {string} [propertyName] Name of property to add. Default is `'should'`.\n * @param {Object} [proto] Prototype to extend with. Default is `Object.prototype`.\n * @memberOf should\n * @returns {{ name: string, descriptor: Object, proto: Object }} Descriptor enough to return all back\n * @static\n * @example\n *\n * var prev = should.extend('must', Object.prototype);\n *\n * 'abc'.must.startWith('a');\n *\n * var should = should.noConflict(prev);\n * should.not.exist(Object.prototype.must);\n */\nshould$1.extend = function(propertyName, proto) {\n  propertyName = propertyName || \"should\";\n  proto = proto || Object.prototype;\n\n  var prevDescriptor = Object.getOwnPropertyDescriptor(proto, propertyName);\n\n  Object.defineProperty(proto, propertyName, {\n    set: function() {},\n    get: function() {\n      return should$1(isWrapperType(this) ? this.valueOf() : this);\n    },\n    configurable: true\n  });\n\n  return { name: propertyName, descriptor: prevDescriptor, proto: proto };\n};\n\n/**\n * Delete previous extension. If `desc` missing it will remove default extension.\n *\n * @param {{ name: string, descriptor: Object, proto: Object }} [desc] Returned from `should.extend` object\n * @memberOf should\n * @returns {Function} Returns should function\n * @static\n * @example\n *\n * var should = require('should').noConflict();\n *\n * should(Object.prototype).not.have.property('should');\n *\n * var prev = should.extend('must', Object.prototype);\n * 'abc'.must.startWith('a');\n * should.noConflict(prev);\n *\n * should(Object.prototype).not.have.property('must');\n */\nshould$1.noConflict = function(desc) {\n  desc = desc || should$1._prevShould;\n\n  if (desc) {\n    delete desc.proto[desc.name];\n\n    if (desc.descriptor) {\n      Object.defineProperty(desc.proto, desc.name, desc.descriptor);\n    }\n  }\n  return should$1;\n};\n\n/**\n * Simple utility function for a bit more easier should assertion extension\n * @param {Function} f So called plugin function. It should accept 2 arguments: `should` function and `Assertion` constructor\n * @memberOf should\n * @returns {Function} Returns `should` function\n * @static\n * @example\n *\n * should.use(function(should, Assertion) {\n *   Assertion.add('asset', function() {\n *      this.params = { operator: 'to be asset' };\n *\n *      this.obj.should.have.property('id').which.is.a.Number();\n *      this.obj.should.have.property('path');\n *  })\n * })\n */\nshould$1.use = function(f) {\n  f(should$1, should$1.Assertion);\n  return this;\n};\n\nshould$1\n  .use(assertExtensions)\n  .use(chainAssertions)\n  .use(booleanAssertions)\n  .use(numberAssertions)\n  .use(equalityAssertions)\n  .use(typeAssertions)\n  .use(stringAssertions)\n  .use(propertyAssertions)\n  .use(errorAssertions)\n  .use(matchingAssertions)\n  .use(containAssertions)\n  .use(promiseAssertions);\n\nvar defaultProto = Object.prototype;\nvar defaultProperty = \"should\";\n\nvar freeGlobal =\n  typeof global == \"object\" && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf =\n  typeof self == \"object\" && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function(\"return this\")();\n\n//Expose api via `Object#should`.\ntry {\n  var prevShould = should$1.extend(defaultProperty, defaultProto);\n  should$1._prevShould = prevShould;\n\n  Object.defineProperty(root, \"should\", {\n    enumerable: false,\n    configurable: true,\n    value: should$1\n  });\n} catch (e) {\n  //ignore errors\n}\n\nmodule.exports = should$1;\n"]}